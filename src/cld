#!/usr/bin/env python3

#Interactive scipt to manage Rclone sync

import os
import subprocess
import sys
import yaml
import shutil
import datetime

#ANSI colors
YELLOW = "\033[33m"
BLUE = "\033[34m"
RED = "\033[31m"
GREEN = "\033[92m"
RESET = "\033[0m" #Reset default to color

#Get command user
USER = os.getlogin()

#PATHS
#Path of sync directory on local system
global_src_path = ""
#Path of sync directory on Google drive
global_dst_path = "/"
# Get the current working directory
CURRENT_DIR = os.getcwd()
#Cache directory
CACHE_DIR = f"/home/{USER}/.cache/cld/"
#Config directory
CONFIG_DIR = f"/home/{USER}/.config/cld/"

#REMOTES
#Personal Google drive remote name
global_personal_remote = ""

#Functions for information messages---------------------------------------------------------------------
def help():
    print("*This command only takes one argument*\n")
    print(" -Perform rclone sync against the remote: 'cld push'")
    print(" -Perform rclone sync against the local system: 'cld pull'")
    print(" -Reset/Create new config for cld: 'cld reset-config'")
    print(" -Delete cld data from system: 'cld delete-all-data'")
    print(" -Get last push and pull dates: 'hist' or 'history'")
    print(" -Verbose: '-v' or 'verbose'")
    print(" -exit codes: 'codes' or 'error-codes'")
    print(" -Help: 'cld help'")

def exit_codes():
    print("Exit codes for cld:")
    print("0 -- Command run successfully")
    print("1 -- General error")
    print("126 -- Shell command could not be run")
    print("127 -- Shell command does not exist in PATH")
    print("128 -- Internal fault")

#Functions for configuration----------------------------------------------------------------------------
def set_active_profile(profile_name: str) -> None:
    try:
        with open(f"{CONFIG_DIR}/active_profile", "w") as file:
            file.write(profile_name)
    except Exception as e:
        print(f"{RED}Error, unable to save active profile.{RESET}")
        exit(128)


def get_active_profile() -> str:
    profile = ""

    try:
        with open(f"{CONFIG_DIR}/active_profile", "r") as file:
            profile = file.read()
            return profile
    except Exception as e:
        print(f"{RED}Error, unable to save active profile.{RESET}")
        exit(128)

def display_profiles() -> None:
    print("Available profiles:")
    for profile in os.listdir(f"{CONFIG_DIR}"):
        if "active_profile" not in profile:
            print(f" {profile}")

def make_or_remove_profile(operation: str) -> None:
    #Variable declarations
    src_path = ""
    dst_path = ""
    personal_remote = ""
    
    if operation == "make":
        #Input from user
        while " " not in profile_name:
            print("Enter the name for the new profile.")
            profile_name = input(f"{YELLOW} Note: profile name may not have spaces{RESET}\n > ")
        src_path = input("Enter the absolute path of the local folder you wish to sync to: ")
        if src_path[-1] != "/":
            src_path = src_path + "/"
        dst_path = input("Enter the absolute path of the remote folder to sync from: ")
        if dst_path[-1] != "/":
            dst_path = dst_path + "/"
        personal_remote = input("Enter the name of your remote set in rclone: ")

        profile_data = {
            "src_path": src_path,
            "dst_path": dst_path,
            "personal_remote": personal_remote
        }

        #Save config
        try:
            with open(f"{CONFIG_DIR}/{profile_name}", "w") as file:
                yaml.dump(profile_data, file)
        except Exception as e:
            print(f"{RED}Error: Unable to save profile.\n E: {e}{RESET}")
            exit(126)

        #Set active profile to new profile
        set_active_profile(profile_name)

    elif operation == "remove":
        profile_name = input("Enter profile(name) to remove > ")
        #Check if directory exists
        if os.path.exists(f"{CONFIG_DIR}/{profile_name}"):
            shutil.rmtree(f"{CONFIG_DIR}/{profile_name}")
            print(f"{GREEN}Profile removed.{RESET}")
        else:
            print(f"{RED}The profile entered does not exist.{RESET}")
    else:
        print(f"{RED}Error, invalid parameter used in make_or_remove_profile{RESET}")
        exit(128)


def make_config():
    print("Welcome to the cld tool!")
    
    #Variable declarations
    setup_rclone = ""

    #Prompt to setup Rclone before cld setup
    print("Rclone must be configured before using cld.\nWould you like to configure it now?")
    while setup_rclone != "y" and setup_rclone != "n":
        setup_rclone = input("(y/n) > ")
        if setup_rclone.lower() == "y":
            try:
                print(f"{GREEN}--> Rclone{RESET}")
                rclone_present = shutil.which("rclone") is not None
                if rclone_present == False:
                    print(f"{RED}Error, Rclone could not be located in PATH. Is it installed?{RESET}")
                    exit(127)
                else:
                    os.system("rclone config")
            except subprocess.CalledProcessError as e:
                print(f"{RED}Error: Unable to execute `rclone config`.\n E: {e}{RESET}")
                exit(126)

    #cld setup
    #Create CACHE directory if it does not exist
    if not os.path.exists(CACHE_DIR):
        os.mkdir(CACHE_DIR)

    #Make profile
    make_profile = input("Would you like to make a new cld profile?\n (y/N) > ")
    if make_profile == "y":
        make_or_remove_profile("make")


def save_push_pull_dates(direction: str):
    current_time = datetime.datetime.now().strftime("%Y-%m-%d %I:%M:%S %p")
    dates_data = {}

    #load timestamp file if it exists
    if os.path.exists(f"{CACHE_DIR}/timestamp"):
        with open(f"{CACHE_DIR}/timestamp","r") as file:
            dates_data = yaml.safe_load(file)
    else:
        dates_data = {
            "last_pull": None,
            "last_push": None
        }

    #Set new date
    if direction == "pull":
        dates_data["last_pull"] = current_time
    elif direction == "push":
        dates_data["last_push"] = current_time
    else:
        print(f"{RED}Error, Invalid parameter sent to `save_push_pull_dates`\n Param sent: {direction}{RESET}")
        exit(128)

    #Save timestamp file
    try:
        with open(f"{CACHE_DIR}/timestamp", "w") as file:
            yaml.dump(dates_data, file)
    except Exception as e:
        print(f"{RED}Error, Unable to save time data.\n E: {e}{RESET}")
        exit(126)


def get_last_push_pull() -> dict:
    dates_data = {}

    #Get time data from file
    if os.path.exists(f"{CACHE_DIR}/timestamp"):
        with open(f"{CACHE_DIR}/timestamp", "r") as file:
            dates_data = yaml.safe_load(file)
    else:
        dates_data = {
            "last_pull": None,
            "last_push": None
        }

    #Display data
    print(f"Last cld pull: {YELLOW}{dates_data["last_pull"]}{RESET}")
    print(f"Last cld push: {YELLOW}{dates_data["last_push"]}{RESET}")


def get_config() -> bool:
    #Global variable declarations
    global global_src_path
    global global_dst_path 
    global global_personal_remote
    global global_active_profile
    
    #Get active profile
    global_active_profile = get_active_profile()

    if os.path.exists(f"{CONFIG_DIR}/{global_active_profile}"):
        with open(f"{CONFIG_DIR}/{global_active_profile}", "r") as file:
            profile_data = yaml.safe_load(file)

        global_src_path = profile_data["src_path"]
        global_dst_path = profile_data["dst_path"]
        global_personal_remote = profile_data["personal_remote"]

        return True #Return true if config is found
    else:
        return False #Return false if config is not found


def delete_all_data():
    try:
        if os.path.exists(CACHE_DIR):
            shutil.rmtree(CACHE_DIR)
        if os.path.exists(CONFIG_DIR):
            shutil.rmtree(CONFIG_DIR)

        print("DATA HAS BEEN REMOVED")
    except Exception as e:
        print(f"{RED}Error, Unable to delete data.\n E: {e}{RESET}")
        exit(126)

#Functions for one-way syncing--------------------------------------------------------
#Get and print changes that will be made to files if rclone sync is used   
def print_changes(direction: str, verbose: bool):
    #commands
    rclone_check_command = f"rclone check {global_src_path} {global_personal_remote}:{global_dst_path} --missing-on-dst {CACHE_DIR}tmp-dst --missing-on-src {CACHE_DIR}tmp-src --differ={CACHE_DIR}tmp-dif --fast-list"
    #Runtime variables
    result = ""
    missing_on_dst = []
    missing_on_src = []
    diff = []

    #Get file changes
    try:
        result = subprocess.run(
            rclone_check_command, 
            capture_output=True, 
            text=True,
            shell=True,
            )
        if verbose == True:
            if len(result.stdout) != 0:
                print(f"\n{YELLOW} --- Rclone output: --- {RESET}")
                print(f"{result.stdout}")
                print(f"\n{YELLOW} --- ----- --- {RESET}")
            if len(result.stderr) != 0:
                print(f"\n{YELLOW} --- Rclone errors: --- {RESET}")
                print(f"{RED}{result.stderr}{RESET}\n")
                print(f"\n{YELLOW} --- ----- --- {RESET}")

    except Exception as e:
        print(f"{RED}Error: Unable to get rclone check against destination.\n E: {e}{RESET}")
        exit(126)
    
    #Read and store directory differences between source and remote
    try:
        with open(f"{CACHE_DIR}tmp-dif", "r") as file:
            for line in file:
                line = line.rstrip("\n")
                diff.append(line)
        os.remove(f"{CACHE_DIR}tmp-dif")
    except Exception as e:
        print(f"{RED}Error: Unable to open/read tmp-dif file.\n E: {e}{RESET}")
        exit(126)

    try:
        with open(f"{CACHE_DIR}tmp-dst", "r") as file:
            for line in file:
                line = line.rstrip("\n")
                missing_on_dst.append(line)
        os.remove(f"{CACHE_DIR}tmp-dst")
    except Exception as e:
        print(f"{RED}Error: Unable to open/read tmp-dst file.\n E: {e}{RESET}")
        exit(126)

    try:
        with open(f"{CACHE_DIR}tmp-src", "r") as file:
            for line in file:
                line = line.rstrip("\n")
                missing_on_src.append(line)
        os.remove(f"{CACHE_DIR}tmp-src")
    except Exception as e:
        print(f"{RED}Error: Unable to open/read tmp-src file.\n E: {e}{RESET}")
        exit(126)

    #Print file changes with respect to instance that is being synced to
    if direction == "pull":
        print(f"File {GREEN}ADD{RESET}/{RED}REMOVE{RESET}/{YELLOW}MODIFY{RESET} made to source(system):")
        if len(missing_on_dst) > 0 or len(missing_on_src) > 0:
            for file_name in missing_on_dst:
                print(f"{RED} -- {file_name}{RESET}")
            for file_name in missing_on_src:
                print(f"{GREEN} ++ {file_name}{RESET}")
            for file_name in diff:
                print(f"{YELLOW} ** {file_name}{RESET}")
        else:
            print(f"{GREEN} None; local and remote match.{RESET}")
    
    elif direction == "push":
        print(f"File {GREEN}ADD{RESET}/{RED}REMOVE{RESET}/{YELLOW}MODIFY{RESET} made to remote(cloud):")
        if len(missing_on_dst) > 0 or len(missing_on_src) > 0:
            for file_name in missing_on_dst:
                print(f"{GREEN} ++ {file_name}{RESET}")
            for file_name in missing_on_src:
                print(f"{RED} -- {file_name}{RESET}")
            for file_name in diff:
                print(f"{YELLOW} ** {file_name}{RESET}")
        else:
            print(f"{GREEN} None; local and remote match.{RESET}")
        
    else:
        print(f"{RED}Error, invalid direction argument sent to print_changes(){RESET}")


#Handles the rclone sync command
def rclone_sync(direction: str, verbose: bool): #direction can be 'push' or 'pull'
    #commands
    rclone_pull_command = f"rclone sync {global_personal_remote}:{global_dst_path} {global_src_path} -P"
    rclone_push_command = f"rclone sync {global_src_path} {global_personal_remote}:{global_dst_path} -P"
    #runtime variables
    choice = ""
    result = ""

    #Print directory differences with respect to the directory being synced
    print(f"{GREEN}ACTIVE PROFILE: {global_active_profile}")
    print_changes(direction, verbose)

    if direction == "pull":
        choice = input("\nWould you like to continue with sync pull?(y/N): ")
        if choice == "y":
            print("Working...")
            try:
                #Source and dest flipped as the local folder is the temporary destination
                result = subprocess.run(
                    rclone_pull_command, 
                    capture_output=True,
                    text=True,
                    shell=True,
                    )
                if verbose == True:
                    if len(result.stdout) != 0:
                        print(f"\n{YELLOW} --- Rclone output: --- {RESET}")
                        print(f"{result.stdout}")
                        print(f"\n{YELLOW} --- ----- --- {RESET}")
                    if len(result.stderr) != 0:
                        print(f"\n{YELLOW} --- Rclone errors: --- {RESET}")
                        print(f"{RED}{result.stderr}{RESET}\n")
                        print(f"\n{YELLOW} --- ----- --- {RESET}")

                save_push_pull_dates("pull")
                print("Done.")
            except Exception as e:
                print("{RED}Error: Unable to pull with rclone.\n E: {e}{RESET}")
                exit(126)
        else:
            print("Sync canceled")
    elif direction == "push":
        choice = input("\nWould you like to continue with sync push?(y/N): ")
        if choice == "y":
            print("Working...")
            try:
                result = subprocess.run(
                    rclone_push_command, 
                    capture_output=True,
                    text=True,
                    shell=True,
                    )
                if verbose == True:
                    if len(result.stdout) != 0:
                        print(f"\n{YELLOW} --- Rclone output: --- {RESET}")
                        print(f"{result.stdout}")
                        print(f"\n{YELLOW} --- ----- --- {RESET}")
                    if len(result.stderr) != 0:
                        print(f"\n{YELLOW} --- Rclone errors: --- {RESET}")
                        print(f"{RED}{result.stderr}{RESET}\n")
                        print(f"\n{YELLOW} --- ----- --- {RESET}")

                save_push_pull_dates("push")
                print("Done.")
            except Exception as e:
                print("{RED}Error: Unable to pull with rclone.\n E: {e}{RESET}")
                exit(126)
        else:
            print("Sync canceled")
    else:
        print("{RED}Error, Invalid direction argument given to rclone-sync(){RESET}")


def main():
    #Flag variables
    push_arg = False
    pull_arg = False
    verbose_arg = False
    delete_data_arg = False
    reset_config_arg = False

    config_found = False


    #Help argument possibility list
    help_arg_list = ["help", "--help", "-h"]
    verbose_arg_list = ["-v", "verbose", "--verbose"]

    #Set flags based on arguments
    for arg in sys.argv:
        if arg == "pull":
            pull_arg = True
        if arg == "push":
            push_arg = True
        if arg in verbose_arg_list:
            verbose_arg = True
        if arg == "reset-config":
            reset_config_arg = True
        if arg == "delete-all-data":
            delete_data_arg = True
        if arg == "history" or arg == "hist":
            get_last_push_pull()
            exit(0)
        if arg in help_arg_list:
            help()
            exit(0)
        if arg == "codes" or arg == "error-codes":
            exit_codes()
            exit(0)
    
    #Load config values from config, get_config() returns a bool for config existance.
    config_found = get_config() 
    if config_found == False:
        make_config()
        exit(0)
    
    #Run command based on arguments
    if push_arg == True:
        rclone_sync(direction="push", verbose=verbose_arg)
    elif pull_arg == True:
        rclone_sync(direction="pull", verbose=verbose_arg)
    elif reset_config_arg == True:
        make_config()
    elif delete_data_arg == True:
        delete_all_data()
    else:
        help()


main()